# DesignPatterns

Testing various design patterns using the book "Head First Design Patterns"

#Strategy Design Pattern

Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

#Observer Design Pattern

Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

#Decorator Design Pattern

Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

#Abstract Factory

Provide an interface for creating families of related or dependent objects without specifying their concrete classes.

#Factory Method

Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to the subclasses.

#Simple Factory // not a Design Pattern

A simple way to decouple your clients from concrete classes. 

#Singleton

Ensure a  class only has one instance and provide a global point of access to it.

#Command Design Pattern

Encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations

#Adapter

Converts the interface of a class into another interface clients expect. Lets classes wortk together that couldn't otherwise because of incompatible features

#Facade

Provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

#Template

Define the skeleton of an algorithm in an operation, deferring some steps to subclasses redefine certain steps of algorithm without changing the algorithm's structure